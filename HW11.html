<!DOCTYPE HTML>
<!--
	Read Only by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Read Only by HTML5 UP</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <script>
            window.MathJax = {
                tex: { inlineMath: [['$','$'], ['\\(','\\)']], displayMath: [['$$','$$'], ['\\[','\\]']] },
                svg: { fontCache: 'global' }
            };
        </script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
        <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background-color: #f8f9fa;
            color: #212529;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 25px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        h1, h2, h3 {
            color: #343a40;
            line-height: 1.3;
        }
        h1 {
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 10px;
        }
        h2 {
            border-top: 1px solid #eee;
            padding-top: 20px;
            margin-top: 30px;
        }
        code, tt {
            background-color: #e9ecef;
            padding: 3px 6px;
            border-radius: 4px;
            font-family: "Courier New", Courier, monospace;
        }
        blockquote {
            border-left: 4px solid #007bff;
            padding-left: 15px;
            margin-left: 0;
            font-style: italic;
            color: #495057;
        }
    </style>
    <style>
        body { font-family: sans-serif; padding: 20px; background-color: #f4f4f9; }
        .container { max-width: 900px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px; padding: 15px; background: #eef; border-radius: 5px; }
        label { font-weight: bold; display: block; margin-bottom: 5px; }
        input, select, button { width: 100%; padding: 8px; box-sizing: border-box; }
        button { background-color: #28a745; color: white; border: none; cursor: pointer; font-size: 16px; margin-top: 20px; }
        button:hover { background-color: #218838; }
        canvas { max-width: 100%; height: 400px; }
        .formula-box { background: #333; color: #fff; padding: 10px; border-radius: 4px; font-family: monospace; margin-top: 10px; }
        /* Rimuovi il vecchio stile 'canvas' e aggiungi questo: */

.chart-wrapper {
    position: relative;
    height: 500px; /* Definisce l'altezza fissa del grafico */
    width: 100%;
    margin-top: 20px;
}
    </style>
	</head>
	<body class="is-preload">

		<!-- Header -->
			<section id="header">
				<header>
					<span class="image avatar"><img src="images/avatar.jpg" alt="" /></span>
					<h1 id="logo"><a href="#">Alessio Mareschi</a></h1>
					<p><a href="index.html">Home</a></p>
					
				</header>
				
				<footer>
					<ul class="icons">
						<li><a href="#" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
						<li><a href="#" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
						<li><a href="#" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="#" class="icon brands fa-github"><span class="label">Github</span></a></li>
						<li><a href="#" class="icon solid fa-envelope"><span class="label">Email</span></a></li>
					</ul>
				</footer>
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<!-- One -->
							<section id="one">
								<div class="image main" data-position="center">
									<img src="images/HW1_image.png" alt="" />
								</div>
								<div class="container">
									<header class="major">
										<h2>Homework 10</h2>
										<p>Simulation: Bernoulli approximation of a Poisson process</p>
									</header>
								</div>
							</section>

							<!-- Two -->
                             <section id="two">

								<div class="container">

                                    <h1>SDE Simulator (Euler-Maruyama)</h1>
    <p>Simulates stochastic processes using the discretized equation:</p>
    <div class="formula-box" id="formula-display">
        dX = 0 * dt + 1 * dW (Wiener Process)
    </div>

    <div class="controls">
        <div>
            <label for="model-type">SDE Model Type:</label>
            <select id="model-type" onchange="updateFormulaDisplay()">
                <option value="wiener">Wiener Process (Brownian Motion)</option>
                <option value="gbm">Geometric Brownian Motion (Stock Price)</option>
                <option value="ou">Ornstein-Uhlenbeck (Mean Reverting)</option>
            </select>
        </div>

        <div>
            <label for="input-n">N (Time Steps):</label>
            <input type="number" id="input-n" value="1000">
        </div>
        <div>
            <label for="input-t">T (Total Time):</label>
            <input type="number" id="input-t" value="1.0">
        </div>
        <div>
            <label for="input-paths">Number of Trajectories:</label>
            <input type="number" id="input-paths" value="50">
        </div>

        <div>
            <label for="input-mu">Param Mu (Drift):</label>
            <input type="number" id="input-mu" value="0" step="0.1">
        </div>
        <div>
            <label for="input-sigma">Param Sigma (Volatility):</label>
            <input type="number" id="input-sigma" value="1" step="0.1">
        </div>
        
        <div>
            <label for="input-x0">X0 (Start Value):</label>
            <input type="number" id="input-x0" value="0">
        </div>
    </div>

    <button onclick="runSimulation()">Run Simulation</button>

    <hr>
    <div class="chart-wrapper">
    <canvas id="sde-chart"></canvas>
</div>


<div class="container" style="margin-top: 30px; border-top: 2px solid #eee; padding-top: 20px;">
    
    <h2>Theoretical Background</h2>
    <p>
        This simulator solves <strong>Stochastic Differential Equations (SDEs)</strong> numerically. 
        Unlike standard calculus where functions are smooth and deterministic, SDEs model systems affected by random "noise".
    </p>

    <h3>1. The General Equation</h3>
    <p>
        Most 1-dimensional stochastic processes can be written in the form:
    </p>
    <div class="formula-box" style="background: #f8f9fa; color: #333; border: 1px solid #ddd;">
        dX(t) = μ(X, t) dt + σ(X, t) dW(t)
    </div>
    <ul>
        <li><strong>dX(t):</strong> The infinitesimal change in the value of the process.</li>
        <li><strong>μ(X, t) dt (Drift):</strong> The <em>deterministic</em> part. It represents the expected trend or velocity of the system.</li>
        <li><strong>σ(X, t) dW (Diffusion):</strong> The <em>stochastic</em> part. It represents volatility or random noise.</li>
        <li><strong>dW(t):</strong> The <strong>Wiener Increment</strong>. It represents the "shock" from Brownian motion.</li>
    </ul>

    <h3>2. The Euler-Maruyama Method</h3>
    <p>
        Computers cannot handle infinitesimal steps (`dt`). To simulate the process, we use the <strong>Euler-Maruyama method</strong>, 
        which is the stochastic equivalent of the Euler method for ODEs. We discretize time into `N` small steps of size `Δt = T/N`.
    </p>
    <p>The discrete update rule used in the JavaScript code is:</p>
    <div class="formula-box" style="background: #eef; color: #333; border: 1px solid #aac;">
        X<sub>next</sub> = X<sub>curr</sub> + μ · Δt + σ · √Δt · Z
    </div>
    <p>
        Where <strong>Z</strong> is a random number drawn from a <strong>Standard Normal Distribution</strong> `N(0, 1)`.
    </p>
    <p>
        <strong>Why √Δt?</strong> This is crucial. In Brownian motion, variance scales linearly with time (`Var ~ t`). 
        Therefore, the standard deviation (which scales the magnitude of the noise) must scale with the square root of time (`Std ~ √t`).
    </p>

    <h3>3. Understanding the Parameters</h3>
    <table border="1" cellpadding="10" cellspacing="0" style="width: 100%; border-collapse: collapse; margin-top: 15px;">
        <thead style="background-color: #eee;">
            <tr>
                <th>Parameter</th>
                <th>Meaning</th>
                <th>Effect on Simulation</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>N (Steps)</strong></td>
                <td>Discretization granularity.</td>
                <td>Higher N means smaller `Δt`. The simulation becomes more accurate and the lines look "noisier" (fractal-like) rather than blocky.</td>
            </tr>
            <tr>
                <td><strong>μ (Mu)</strong></td>
                <td>The Drift coefficient.</td>
                <td>Controls the <strong>trend</strong>. <br>Positive μ: The graph tends to go up.<br>Negative μ: The graph tends to go down.</td>
            </tr>
            <tr>
                <td><strong>σ (Sigma)</strong></td>
                <td>The Diffusion coefficient (Volatility).</td>
                <td>Controls the <strong>randomness</strong>. <br>High σ: The paths are very jagged and spread out widely.<br>σ = 0: The process becomes a deterministic straight line.</td>
            </tr>
            <tr>
                <td><strong>T (Time)</strong></td>
                <td>Time Horizon.</td>
                <td>How long the simulation runs (e.g., 1 year).</td>
            </tr>
        </tbody>
    </table>

    <h3>4. The Specific Models Implemented</h3>
    
    <h4>A. Wiener Process (Standard Brownian Motion)</h4>
    <p>
        <code>dX = 0·dt + 1·dW</code> (or generalized with constant μ and σ).<br>
        The "noise" is constant. Used in physics to model particle diffusion. 
        <br><em>Key Feature:</em> It can go negative. The variance grows linearly with time.
    </p>

    <h4>B. Geometric Brownian Motion (GBM)</h4>
    <p>
        <code>dX = μX·dt + σX·dW</code><br>
        The noise and trend are proportional to the current value `X`. Used in finance (Black-Scholes model) for stock prices.
        <br><em>Key Feature:</em> If started at positive X0, it never goes negative (prices can't be below zero). The noise gets larger as the value gets larger.
    </p>

    <h4>C. Ornstein-Uhlenbeck (Mean Reverting)</h4>
    <p>
        <code>dX = θ(μ - X)·dt + σ·dW</code><br>
        The drift pulls the value towards a long-term mean `μ`. Used for interest rates or volatility modeling.
        <br><em>Key Feature:</em> It doesn't wander off to infinity like the others; it fluctuates around a stable center.
    </p>

</div>

    
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
    let myChart = null;

    // --- 1. GAUSSIAN GENERATOR (Box-Muller Transform) ---
    // JavaScript's Math.random() is Uniform(0,1). We need Normal(0,1).
    function generateGaussian() {
        let u = 0, v = 0;
        while(u === 0) u = Math.random(); // Converting [0,1) to (0,1)
        while(v === 0) v = Math.random();
        return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
    }

    // --- 2. EULER-MARUYAMA SOLVER ---
    /**
     * @param {number} n_steps - Number of discretization steps
     * @param {number} T - Total time horizon
     * @param {number} x0 - Initial value
     * @param {function} driftFn - Function returning drift (mu) based on current x and t
     * @param {function} diffusionFn - Function returning diffusion (sigma) based on current x and t
     */
    function simulateSDE(n_steps, T, x0, driftFn, diffusionFn) {
        const dt = T / n_steps;
        const sqrt_dt = Math.sqrt(dt);
        
        let path = new Float32Array(n_steps + 1); // Using typed array for performance
        path[0] = x0;

        for (let i = 0; i < n_steps; i++) {
            const t = i * dt;
            const currentX = path[i];
            
            // Generate Wiener increment dW
            const Z = generateGaussian(); 
            const dW = sqrt_dt * Z;

            // Calculate components
            const drift = driftFn(currentX, t) * dt;
            const diffusion = diffusionFn(currentX, t) * dW;

            // Euler step: X(t+1) = X(t) + Drift + Diffusion
            path[i+1] = currentX + drift + diffusion;
        }
        return path;
    }

    // --- 3. DEFINITION OF MODELS (The "Generalized" part) ---
    const models = {
        'wiener': {
            // dX = mu*dt + sigma*dW (Standard: mu=0, sigma=1)
            getDrift: (mu) => (x, t) => mu, 
            getDiff: (sigma) => (x, t) => sigma,
            defaultX0: 0
        },
        'gbm': {
            // dX = mu*X*dt + sigma*X*dW (Stocks)
            getDrift: (mu) => (x, t) => mu * x,
            getDiff: (sigma) => (x, t) => sigma * x,
            defaultX0: 100
        },
        'ou': {
            // dX = theta*(mu - X)*dt + sigma*dW (Mean Reverting)
            // We use the input 'mu' as the long-term mean, and fix theta for simplicity
            getDrift: (mu) => (x, t) => 2.0 * (mu - x), // theta = 2.0
            getDiff: (sigma) => (x, t) => sigma,
            defaultX0: mu => mu // Start at mean usually
        }
    };

    function runSimulation() {
        // Read Inputs
        const modelKey = document.getElementById('model-type').value;
        const N = parseInt(document.getElementById('input-n').value);
        const T = parseFloat(document.getElementById('input-t').value);
        const numPaths = parseInt(document.getElementById('input-paths').value);
        const muParam = parseFloat(document.getElementById('input-mu').value);
        const sigmaParam = parseFloat(document.getElementById('input-sigma').value);
        const x0 = parseFloat(document.getElementById('input-x0').value);

        // Configure the Functions based on selection
        const selectedModel = models[modelKey];
        const driftFunction = selectedModel.getDrift(muParam);
        const diffusionFunction = selectedModel.getDiff(sigmaParam);

        // Run simulations
        const datasets = [];
        // Only verify logic for reasonable number of datasets to render
        const limitPaths = Math.min(numPaths, 100); 

        for(let i=0; i<limitPaths; i++) {
            const pathData = simulateSDE(N, T, x0, driftFunction, diffusionFunction);
            
            // Downsample for charting if N is huge (Chart.js can lag with >2000 points)
            const plotData = [];
            const stepSize = Math.max(1, Math.floor(N / 500));
            
            for(let j=0; j<=N; j+=stepSize) {
                plotData.push({x: j * (T/N), y: pathData[j]});
            }

            datasets.push({
                label: `Path ${i}`,
                data: plotData,
                borderColor: i === 0 ? 'rgba(255, 99, 132, 1)' : 'rgba(54, 162, 235, 0.3)', // First path red, others blueish transparent
                borderWidth: i === 0 ? 2 : 1,
                pointRadius: 0,
                fill: false
            });
        }

        drawChart(datasets, T);
    }

    function drawChart(datasets, T) {
        const ctx = document.getElementById('sde-chart').getContext('2d');
        if (myChart) myChart.destroy();

        myChart = new Chart(ctx, {
            // PRIMA ERA 'scatter', ORA METTIAMO 'line'
            type: 'line', 
            
            data: { datasets: datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                
                // Ottimizzazioni per le performance (opzionali ma utili per molte linee)
                elements: {
                    line: {
                        tension: 0 // Disegna linee dritte (non curve smussate) per performance migliori
                    },
                    point: {
                        radius: 0 // Assicura che non disegni i pallini sui vertici
                    }
                },

                scales: {
                    // Importante: type: 'linear' serve per gestire l'asse X numerico con type: 'line'
                    x: { type: 'linear', position: 'bottom', title: {display: true, text: 'Time (t)'}, max: T },
                    y: { title: {display: true, text: 'Value X(t)'} }
                },
                plugins: {
                    legend: { display: false },
                    title: { display: true, text: 'Stochastic Trajectories' }
                },
                animation: false
            }
        });
    }
        const ctx = document.getElementById('sde-chart').getContext('2d');
        if (myChart) myChart.destroy();

        myChart = new Chart(ctx, {
            type: 'scatter', // Scatter with lines allows numeric X axis
            data: { datasets: datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { type: 'linear', position: 'bottom', title: {display: true, text: 'Time (t)'}, max: T },
                    y: { title: {display: true, text: 'Value X(t)'} }
                },
                plugins: {
                    legend: { display: false },
                    title: { display: true, text: 'Stochastic Trajectories' }
                },
                animation: false
            }
        });
    

    function updateFormulaDisplay() {
        const type = document.getElementById('model-type').value;
        const div = document.getElementById('formula-display');
        const x0Input = document.getElementById('input-x0');

        if(type === 'wiener') {
            div.innerText = "dX_t = μ dt + σ dW_t (Standard: μ=0, σ=1)";
            x0Input.value = 0;
        } else if (type === 'gbm') {
            div.innerText = "dX_t = μ X_t dt + σ X_t dW_t (Geometric)";
            x0Input.value = 100;
        } else if (type === 'ou') {
            div.innerText = "dX_t = θ(μ - X_t) dt + σ dW_t (Ornstein-Uhlenbeck)";
            x0Input.value = 0;
        }
    }
    
    // Init
    updateFormulaDisplay();
</script>
    

								

                        </div>
							</section>

						
						<!-- Three -->
							

						

						

					</div>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<ul class="copyright">
								<li>&copy; Untitled. All rights reserved.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
							</ul>
						</div>
					</section>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>